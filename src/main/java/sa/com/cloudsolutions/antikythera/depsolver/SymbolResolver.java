package sa.com.cloudsolutions.antikythera.depsolver;

import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.TypeDeclaration;
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.body.FieldDeclaration;
import com.github.javaparser.ast.expr.Expression;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.ast.nodeTypes.NodeWithSimpleName;
import com.github.javaparser.ast.type.ClassOrInterfaceType;
import com.github.javaparser.ast.type.Type;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import sa.com.cloudsolutions.antikythera.evaluator.AntikytheraRunTime;
import sa.com.cloudsolutions.antikythera.parser.AbstractCompiler;
import sa.com.cloudsolutions.antikythera.parser.ImportWrapper;

import java.lang.reflect.Field;
import java.util.Map;
import java.util.Optional;

/**
 * A utility class for performing static analysis and symbol resolution
 * without dependencies on the GraphNode structure.
 */
public class SymbolResolver {
    private static final Logger logger = LoggerFactory.getLogger(SymbolResolver.class);

    private SymbolResolver() {
    }

    /**
     * Attempts to resolve methods generated by Lombok annotations (Getter, Setter,
     * Data).
     * Infers the field type based on the accessor/mutator name.
     *
     * @param argMethodCall the method call expression (e.g., `getFoo()`)
     * @param cid           the class declaration to check for Lombok annotations
     *                      and fields
     * @return an Optional containing the resolved Type if successful, otherwise
     *         empty
     */
    public static Optional<Type> resolveLombokFieldType(MethodCallExpr argMethodCall, ClassOrInterfaceDeclaration cid) {
        if ((argMethodCall.getNameAsString().startsWith("get") || argMethodCall.getNameAsString().startsWith("set") &&
                (cid.getAnnotationByName("Data").isPresent() || cid.getAnnotationByName("Getter").isPresent()))) {
            String field = argMethodCall.getNameAsString().substring(3);
            if (!field.isEmpty()) {
                Optional<FieldDeclaration> fd = cid.getFieldByName(AbstractCompiler.classToInstanceName(field));
                if (fd.isPresent()) {
                    return Optional.ofNullable(fd.get().getElementType());
                }
            }
        }
        return Optional.empty();
    }

    /**
     * Attempts to resolve a type from an external library using reflection.
     *
     * @param fae the node containing the simple name of the field to resolve
     * @param imp the import wrapper containing information about the external
     *            import
     * @return an Optional containing the resolved ClassOrInterfaceType if
     *         successful, otherwise empty
     */
    public static Optional<Type> getExternalType(NodeWithSimpleName<?> fae, ImportWrapper imp) {
        try {
            Class<?> c = Class.forName(imp.getNameAsString());
            Field f = c.getField(fae.getNameAsString());
            ClassOrInterfaceType ct = new ClassOrInterfaceType(null, f.getType().getTypeName());
            return Optional.of(ct);

        } catch (ReflectiveOperationException e) {
            logger.error(e.getMessage());
        }
        return Optional.empty();
    }

    /**
     * Resolves a scoped name expression.
     * Determines if the name corresponds to a known type, an import, or an internal
     * type declaration.
     *
     * @param scope the scope expression
     * @param cu    the compilation unit context
     * @param names map of known names to types
     * @return an Optional containing the ScopedResolution result
     */
    public static Optional<ScopedResolution> resolveScopedName(Expression scope, CompilationUnit cu,
            Map<String, Type> names) {
        if (names != null) {
            Type t = names.get(scope.asNameExpr().getNameAsString());
            if (t != null) {
                return Optional.of(new ScopedResolution(t, null, null));
            }
        }

        ImportWrapper imp = AbstractCompiler.findImport(cu, scope.asNameExpr().getNameAsString());
        if (imp != null) {
            return resolveScopedNameThroughImport(imp);
        }

        return Optional.empty();
    }

    static Optional<ScopedResolution> resolveScopedNameThroughImport(ImportWrapper imp) {
        if (imp.isExternal()) {
            return Optional.of(new ScopedResolution(null, imp, null));
        }

        if (imp.getField() == null) {
            if (imp.getImport().isAsterisk()) {
                return Optional.of(new ScopedResolution(null, imp, imp.getType()));
            } else {
                CompilationUnit externalCu = AntikytheraRunTime
                        .getCompilationUnit(imp.getImport().getNameAsString());
                if (externalCu != null) {
                    TypeDeclaration<?> td = AbstractCompiler.getPublicType(externalCu);
                    return Optional.of(new ScopedResolution(null, imp, td));
                }
            }
            // Return just the import if no type declaration could be resolved but it's not
            // a field
            return Optional.of(new ScopedResolution(null, imp, null));
        }
        // Return just the import if it refers to a field (handled by caller typically)
        return Optional.of(new ScopedResolution(null, imp, null));
    }
}
