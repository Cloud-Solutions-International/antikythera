package sa.com.cloudsolutions.antikythera.parser.converter;

import org.junit.jupiter.api.Test;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

class MethodToSQLConverterTest {

    @Test
    void testBuildSelectAndWhereClauses_FindAll() {
        StringBuilder sql = new StringBuilder();
        MethodToSQLConverter.buildSelectAndWhereClauses(List.of("findAll"), sql, "users");
        assertEquals("SELECT * FROM users", sql.toString());
    }

    @Test
    void testBuildSelectAndWhereClauses_FindAllById() {
        StringBuilder sql = new StringBuilder();
        MethodToSQLConverter.buildSelectAndWhereClauses(List.of("findAllById"), sql, "users");
        assertEquals("SELECT * FROM users WHERE id IN (?)", sql.toString());
    }

    @Test
    void testBuildSelectAndWhereClauses_FindBy() {
        StringBuilder sql = new StringBuilder();
        MethodToSQLConverter.buildSelectAndWhereClauses(List.of("findBy", "Name"), sql, "users");
        assertEquals("SELECT * FROM users WHERE name = ? ", sql.toString());
    }

    @Test
    void testBuildSelectAndWhereClauses_CountBy() {
        StringBuilder sql = new StringBuilder();
        MethodToSQLConverter.buildSelectAndWhereClauses(List.of("countBy", "Active"), sql, "users");
        assertEquals("SELECT COUNT(*) FROM users WHERE active = ? ", sql.toString());
    }

    @Test
    void testBuildSelectAndWhereClauses_DeleteBy() {
        StringBuilder sql = new StringBuilder();
        MethodToSQLConverter.buildSelectAndWhereClauses(List.of("deleteBy", "Id"), sql, "users");
        assertEquals("DELETE FROM users WHERE id = ? ", sql.toString());
    }

    @Test
    void testBuildSelectAndWhereClauses_ExistsBy() {
        // Note: The closing parenthesis for EXISTS is added by BaseRepositoryParser.parseNonAnnotatedMethod()
        // This test verifies the SQL fragment generated by buildSelectAndWhereClauses
        StringBuilder sql = new StringBuilder();
        MethodToSQLConverter.buildSelectAndWhereClauses(List.of("existsBy", "Email"), sql, "users");
        assertEquals("SELECT EXISTS (SELECT 1 FROM users WHERE email = ? ", sql.toString());
    }

    @Test
    void testBuildSelectAndWhereClauses_FindFirstBy() {
        StringBuilder sql = new StringBuilder();
        boolean top = MethodToSQLConverter.buildSelectAndWhereClauses(List.of("findFirstBy", "Name"), sql, "users");
        assertTrue(top);
        assertEquals("SELECT * FROM users WHERE name = ? ", sql.toString());
    }

    @Test
    void testBuildSelectAndWhereClauses_FindTopBy() {
        StringBuilder sql = new StringBuilder();
        boolean top = MethodToSQLConverter.buildSelectAndWhereClauses(List.of("findTopBy", "Age"), sql, "users");
        assertTrue(top);
        assertEquals("SELECT * FROM users WHERE age = ? ", sql.toString());
    }

    @Test
    void testBuildSelectAndWhereClauses_FindDistinctBy() {
        StringBuilder sql = new StringBuilder();
        MethodToSQLConverter.buildSelectAndWhereClauses(List.of("findDistinctBy", "Name"), sql, "users");
        assertEquals("SELECT DISTINCT * FROM users WHERE name = ? ", sql.toString());
    }

    @Test
    void testBuildSelectAndWhereClauses_Operators() {
        StringBuilder sql = new StringBuilder();
        List<String> components = List.of("findBy", "Age", "GreaterThan", "And", "Name", "In");
        MethodToSQLConverter.buildSelectAndWhereClauses(components, sql, "users");
        assertEquals("SELECT * FROM users WHERE age  > ?  AND name  IN (?) ", sql.toString());
    }

    @Test
    void testBuildSelectAndWhereClauses_Not() {
        StringBuilder sql = new StringBuilder();
        // Standalone Not -> != ?
        MethodToSQLConverter.buildSelectAndWhereClauses(List.of("findBy", "Active", "Not"), sql, "users");
        assertEquals("SELECT * FROM users WHERE active != ? ", sql.toString());
    }

    @Test
    void testBuildSelectAndWhereClauses_NotLike() {
        StringBuilder sql = new StringBuilder();
        // Not Like -> NOT LIKE ?
        MethodToSQLConverter.buildSelectAndWhereClauses(List.of("findBy", "Name", "Not", "Like"), sql, "users");
        assertEquals("SELECT * FROM users WHERE name NOT LIKE ? ", sql.toString());
    }

    @Test
    void testBuildSelectAndWhereClauses_StartingWithEndingWith() {
        StringBuilder sql = new StringBuilder();
        MethodToSQLConverter.buildSelectAndWhereClauses(
                List.of("findBy", "Name", "StartingWith", "And", "Email", "EndingWith"), sql, "users");
        assertEquals("SELECT * FROM users WHERE name LIKE ?  AND email LIKE ? ", sql.toString());
    }

    @Test
    void testBuildSelectAndWhereClauses_BeforeAfter() {
        StringBuilder sql = new StringBuilder();
        MethodToSQLConverter.buildSelectAndWhereClauses(List.of("findBy", "Date", "Before", "And", "Time", "After"),
                sql, "users");
        assertEquals("SELECT * FROM users WHERE date  < ?  AND time  > ? ", sql.toString());
    }

    @Test
    void testBuildSelectAndWhereClauses_TrueFalse() {
        StringBuilder sql = new StringBuilder();
        MethodToSQLConverter.buildSelectAndWhereClauses(List.of("findBy", "Active", "True", "And", "Deleted", "False"),
                sql, "users");
        assertEquals("SELECT * FROM users WHERE active  = true  AND deleted  = false ", sql.toString());
    }

    @Test
    void testBuildSelectAndWhereClauses_IsEquals() {
        StringBuilder sql = new StringBuilder();
        MethodToSQLConverter.buildSelectAndWhereClauses(List.of("findBy", "Name", "Is", "And", "Age", "Equals"), sql,
                "users");
        assertEquals("SELECT * FROM users WHERE name = ?  AND age = ? ", sql.toString());
    }

    @Test
    void testBuildSelectAndWhereClauses_OrderBy() {
        StringBuilder sql = new StringBuilder();
        MethodToSQLConverter.buildSelectAndWhereClauses(List.of("findAll", "OrderBy", "Name", "Desc"), sql, "users");
        assertEquals("SELECT * FROM users ORDER BY name DESC ", sql.toString());
    }

    @Test
    void testBuildSelectAndWhereClauses_LowercaseStartingFieldName() {
        // Test realistic scenario: field starting with lowercase (e.g.,
        // eApprovalStatus)
        // This demonstrates the fix for processing methods like:
        // findByeApprovalStatusIsNotNull
        StringBuilder sql = new StringBuilder();
        List<String> components = List.of("findBy", "eApprovalStatus", "IsNotNull");
        MethodToSQLConverter.buildSelectAndWhereClauses(components, sql, "approvals");
        assertEquals("SELECT * FROM approvals WHERE e_approval_status  IS NOT NULL ", sql.toString());
    }

    @Test
    void testBuildSelectAndWhereClauses_MultipleLowercaseFieldsAnonymized() {
        // Anonymized test: multiple fields starting with lowercase letters separated by
        // And
        StringBuilder sql = new StringBuilder();
        List<String> components = List.of("findBy", "xStatus", "IsNot", "And", "yDeleted", "And", "zActive");
        MethodToSQLConverter.buildSelectAndWhereClauses(components, sql, "records");
        assertEquals("SELECT * FROM records WHERE x_status  != ?  AND y_deleted = ?  AND z_active = ? ",
                sql.toString());
    }

    @Test
    void testExtractComponents_DoesNotSplitInsideOrderFields() {
        // Tests that 'Or' inside OrderId/OrderType is not treated as a logical operator.
        // Also tests that 'IsActive' is treated as a single field name (property named isActive),
        // NOT as 'Is' operator + 'Active' field. This aligns with Spring Data JPA conventions.
        List<String> components = MethodToSQLConverter.extractComponents("findByOrderIdAndOrderTypeAndIsActive");
        assertEquals(List.of("findBy", "OrderId", "And", "OrderType", "And", "IsActive"), components,
                "Components should not split 'Or' inside OrderId/OrderType, and 'IsActive' should be a single field");
    }

    @Test
    void testSQL_For_OrderId_OrderType_IsActive() {
        // 'IsActive' is a property name (common for boolean fields in Java), not 'Is' + 'Active'
        List<String> components = MethodToSQLConverter.extractComponents("findByOrderIdAndOrderTypeAndIsActive");
        StringBuilder sql = new StringBuilder();
        MethodToSQLConverter.buildSelectAndWhereClauses(components, sql, "orders");
        assertEquals("SELECT * FROM orders WHERE order_id = ?  AND order_type = ?  AND is_active = ? ", sql.toString());
    }

    @Test
    void testExtractComponents_DoesNotTreatOrInsideOrganizationAsOperator() {
        List<String> components = MethodToSQLConverter.extractComponents("findByOrganization");
        assertEquals(List.of("findBy", "Organization"), components);
        StringBuilder sql = new StringBuilder();
        MethodToSQLConverter.buildSelectAndWhereClauses(components, sql, "users");
        assertEquals("SELECT * FROM users WHERE organization = ? ", sql.toString());
    }

    @Test
    void testBuildSelectAndWhereClauses_IsTrue_Anonymized() {
        // Anonymized test for methods with IsTrue hardcoded in signature
        // e.g., findByContractIdAndStatusIsTrue(long contractId)
        // should generate: WHERE contract_id = ? AND status = true
        StringBuilder sql = new StringBuilder();
        List<String> components = List.of("findBy", "ContractId", "And", "Status", "IsTrue");
        MethodToSQLConverter.buildSelectAndWhereClauses(components, sql, "records");
        assertEquals("SELECT * FROM records WHERE contract_id = ?  AND status = true ", sql.toString());
    }

    @Test
    void testBuildSelectAndWhereClauses_IsFalse_Anonymized() {
        // Anonymized test for methods with IsFalse hardcoded in signature
        // e.g., findByUserIdAndDeletedIsFalse(long userId)
        // should generate: WHERE user_id = ? AND deleted = false
        StringBuilder sql = new StringBuilder();
        List<String> components = List.of("findBy", "UserId", "And", "Deleted", "IsFalse");
        MethodToSQLConverter.buildSelectAndWhereClauses(components, sql, "records");
        assertEquals("SELECT * FROM records WHERE user_id = ?  AND deleted = false ", sql.toString());
    }

    @Test
    void testExtractComponents_IsTrue() {
        // Verify that IsTrue is recognized as a separate keyword from the field name
        List<String> components = MethodToSQLConverter.extractComponents("findByContractIdAndStatusIsTrue");
        assertEquals(List.of("findBy", "ContractId", "And", "Status", "IsTrue"), components);
    }

    @Test
    void testExtractComponents_IsFalse() {
        // Verify that IsFalse is recognized as a separate keyword from the field name
        List<String> components = MethodToSQLConverter.extractComponents("findByUserIdAndDeletedIsFalse");
        assertEquals(List.of("findBy", "UserId", "And", "Deleted", "IsFalse"), components);
    }

    @Test
    void testBuildSelectAndWhereClauses_IsActiveIsFalse() {
        StringBuilder sql = new StringBuilder();
        List<String> components = List.of("findBy", "PayerContractId", "And", "IsActive", "IsFalse");
        MethodToSQLConverter.buildSelectAndWhereClauses(components, sql, "contracts");
        assertEquals("SELECT * FROM contracts WHERE payer_contract_id = ?  AND is_active = false ", sql.toString());
    }

    @Test
    void testBuildSelectAndWhereClauses_IsActiveIsTrueAndDeletedIsFalse() {
        StringBuilder sql = new StringBuilder();
        List<String> components = List.of("findBy", "IsActive", "IsTrue", "And", "Deleted", "IsFalse");
        MethodToSQLConverter.buildSelectAndWhereClauses(components, sql, "users");
        assertEquals("SELECT * FROM users WHERE is_active = true  AND deleted = false ", sql.toString());
    }

    @Test
    void testBuildSelectAndWhereClauses_StatusIsTrueOrStatusIsFalse() {
        StringBuilder sql = new StringBuilder();
        List<String> components = List.of("findBy", "Status", "IsTrue", "Or", "Status", "IsFalse");
        MethodToSQLConverter.buildSelectAndWhereClauses(components, sql, "records");
        assertEquals("SELECT * FROM records WHERE status = true  OR status = false ", sql.toString());
    }

    @Test
    void testBuildSelectAndWhereClauses_IsActiveNot() {
        StringBuilder sql = new StringBuilder();
        List<String> components = List.of("findBy", "IsActive", "Not");
        MethodToSQLConverter.buildSelectAndWhereClauses(components, sql, "users");
        assertEquals("SELECT * FROM users WHERE is_active != ? ", sql.toString());
    }

    @Test
    void testBuildSelectAndWhereClauses_IsActiveIsTrueAndNameContaining() {
        StringBuilder sql = new StringBuilder();
        List<String> components = List.of("findBy", "IsActive", "IsTrue", "And", "Name", "Containing");
        MethodToSQLConverter.buildSelectAndWhereClauses(components, sql, "users");
        assertEquals("SELECT * FROM users WHERE is_active = true  AND name LIKE ? ", sql.toString());
    }

    @Test
    void testBuildSelectAndWhereClauses_IsActiveIsTrueOrderByCreatedAtDesc() {
        StringBuilder sql = new StringBuilder();
        List<String> components = List.of("findBy", "IsActive", "IsTrue", "OrderBy", "CreatedAt", "Desc");
        MethodToSQLConverter.buildSelectAndWhereClauses(components, sql, "users");
        assertEquals("SELECT * FROM users WHERE is_active = true  ORDER BY created_at DESC ", sql.toString());
    }

    @Test
    void testBuildSelectAndWhereClauses_IsActiveIsTrueAndIsVerifiedIsFalse() {
        StringBuilder sql = new StringBuilder();
        List<String> components = List.of("findBy", "IsActive", "IsTrue", "And", "IsVerified", "IsFalse");
        MethodToSQLConverter.buildSelectAndWhereClauses(components, sql, "users");
        assertEquals("SELECT * FROM users WHERE is_active = true  AND is_verified = false ", sql.toString());
    }

    @Test
    void testExtractComponents_FindAllByIsActive() {
        List<String> components = MethodToSQLConverter.extractComponents("findAllByIsActive");
        assertEquals(List.of("findAllBy", "IsActive"), components);
    }

    @Test
    void testBuildSelectAndWhereClauses_FindAllByIsActive() {
        StringBuilder sql = new StringBuilder();
        List<String> components = List.of("findAllBy", "IsActive");
        MethodToSQLConverter.buildSelectAndWhereClauses(components, sql, "appointment_schedule");
        assertEquals("SELECT * FROM appointment_schedule WHERE is_active = ? ", sql.toString());
    }

    @Test
    void testExtractComponents_ExistsAllByAvailable() {
        List<String> components = MethodToSQLConverter.extractComponents("existsAllByAvailableAndResourceLinkInAndLevel");
        assertEquals(List.of("existsAllBy", "Available", "And", "ResourceLink", "In", "And", "Level"), components);
    }

    @Test
    void testBuildSelectAndWhereClauses_ExistsAllBy() {
        StringBuilder sql = new StringBuilder();
        List<String> components = List.of("existsAllBy", "Available", "And", "ResourceLink", "In");
        MethodToSQLConverter.buildSelectAndWhereClauses(components, sql, "resources");
        // Note: There's a space before IN (?) due to the appendDefaultComponent logic
        assertEquals("SELECT EXISTS (SELECT 1 FROM resources WHERE available = ?  AND resource_link  IN (?) ", sql.toString());
    }

    @Test
    void testExtractComponents_CountAllByStatus() {
        List<String> components = MethodToSQLConverter.extractComponents("countAllByStatus");
        assertEquals(List.of("countAllBy", "Status"), components);
    }

    @Test
    void testBuildSelectAndWhereClauses_CountAllBy() {
        StringBuilder sql = new StringBuilder();
        List<String> components = List.of("countAllBy", "Status");
        MethodToSQLConverter.buildSelectAndWhereClauses(components, sql, "orders");
        assertEquals("SELECT COUNT(*) FROM orders WHERE status = ? ", sql.toString());
    }

    @Test
    void testExtractComponents_DeleteAllByExpired() {
        List<String> components = MethodToSQLConverter.extractComponents("deleteAllByExpiredIsTrue");
        assertEquals(List.of("deleteAllBy", "Expired", "IsTrue"), components);
    }

    @Test
    void testBuildSelectAndWhereClauses_DeleteAllBy() {
        StringBuilder sql = new StringBuilder();
        List<String> components = List.of("deleteAllBy", "Expired", "IsTrue");
        MethodToSQLConverter.buildSelectAndWhereClauses(components, sql, "sessions");
        assertEquals("DELETE FROM sessions WHERE expired = true ", sql.toString());
    }

    @Test
    void testExtractComponents_IgnoreCase() {
        List<String> components = MethodToSQLConverter.extractComponents("findByNameIgnoreCase");
        assertEquals(List.of("findBy", "Name", "IgnoreCase"), components);
    }

    @Test
    void testBuildSelectAndWhereClauses_IgnoreCase() {
        // IGNORE_CASE should still produce a valid query with = ?
        // Case-insensitive comparison is handled at the application/database layer
        StringBuilder sql = new StringBuilder();
        List<String> components = List.of("findBy", "Name", "IgnoreCase");
        MethodToSQLConverter.buildSelectAndWhereClauses(components, sql, "users");
        assertEquals("SELECT * FROM users WHERE name = ? ", sql.toString());
    }

    @Test
    void testBuildSelectAndWhereClauses_MultipleFieldsWithIgnoreCase() {
        StringBuilder sql = new StringBuilder();
        List<String> components = List.of("findBy", "FirstName", "IgnoreCase", "And", "LastName", "IgnoreCase");
        MethodToSQLConverter.buildSelectAndWhereClauses(components, sql, "users");
        assertEquals("SELECT * FROM users WHERE first_name = ?  AND last_name = ? ", sql.toString());
    }

    @Test
    void testBuildSelectAndWhereClauses_AllIgnoreCase() {
        // AllIgnoreCase modifier at the end applies case-insensitivity to all fields
        StringBuilder sql = new StringBuilder();
        List<String> components = List.of("findBy", "FirstName", "And", "LastName", "AllIgnoreCase");
        MethodToSQLConverter.buildSelectAndWhereClauses(components, sql, "users");
        assertEquals("SELECT * FROM users WHERE first_name = ?  AND last_name = ? ", sql.toString());
    }
}
